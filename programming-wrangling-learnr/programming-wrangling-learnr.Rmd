---
title: Programming & Wrangling
author: Andrew Barr
output: learnr::tutorial
runtime: shiny_prerendered
---

## the `tidyverse`

`tidyverse` is a series of R packages that has revolutionized working with data in R.

It provides a consistent and simple interface to do common data manipulation tasks

### the dplyr package

`dplyr` is a package within the tidyverse for manipulating dataframes.  It is very consistent. 

`dplyr` assumes that you are starting with a dataframe, doing something to that dataframe, and finishing with a different dataframe. 

Many of the base R functions operate on atomic vectors, which makes it more complicated to apply them to dataframes.

`dplyr` introduces a series of simple 'verbs' that describe many common data manipulation tasks. 

## Read dataset 

We will be using a dataset on student loans in public and private universities.

We can read it in using `read.table()` [DMV_2014_Q3_Undergrad_DirectLoans.txt](stats.are-awesome.com/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt) and save it to a variable called `loans`.

```{r}
loans<-read.table('https://stats.are-awesome.com/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt', header=T, sep=",")
```


## The basic dplyr verbs

There are a few basic functions in `dplyr`

The first argument to these functions is always the dataframe that you want to manipulate. 

Within these function calls, you can refer to the names of columns in the dataframe without quotation marks and without the usual `$` syntax. 

Here, we first load the `dplyr` package to get access to these functions, which are not available in R by default (they live in the `dplyr` package). If you don't want to load all the functions in a particular library, you can refer to them like this `packageName::functionName`, but most commonly you will load the entire package.  

```{r warning=FALSE, message=FALSE}
library(dplyr)
```

## `filter()` 

This function selects a subset of rows meeting some criterion.  Note that the result is a dataframe. 

```{r warning=FALSE, message=FALSE}
filter(loans, School=="GEORGE WASHINGTON UNIVERSITY")
```

Note, you can add multiple filter conditions.  You will get back all the rows for which all the conditions are TRUE. For example, this code gives you all the public universities in DC. 

```{r}
filter(loans, State=="DC", School_Type=="Public")
```

### Challenge

Use the `dplyr::filter()` function to get the data for "AMERICAN UNIVERSITY". 

```{r, filterAMERICAN, exercise=TRUE}
```

### Double bonus challenge

Use the `dplyr::filter()` function to get the data for GEORGE WASHINGTON UNIVERSITY and GALLAUDET UNIVERSITY in a single line of code.  Hint: use the `%in%` operator instead of the `==` operator to pass a vector of possible school names. 

```{r filterGWUGALLAUDET, exercise=TRUE}
```

### 

## `arrange()`

This function is like the "sort" function in MS Excel.  You simply provide a list of column names to sort by:

```{r}
arrange(loans, State, SubsidizedDL)
arrange(loans, State, desc(SubsidizedDL))
```

## `select()`

This function pulls out columns of interest.  You can select ranges of columns using the `:` operator syntax. (Note: usually this only works with numeric data, but this is a special usage defined in the `dplyr` package)

```{r}
select(loans, State, SubsidizedDL)
select(loans, -State, -SubsidizedDL)
select(loans, State:SubsidizedDL)
```

## `distinct()`

This function extracts the distinct rows.  It is most useful when combined with select

```{r}
distinct(loans)
distinct(select(loans, State, School_Type))
```

## `mutate()`

Adds new columns that are some function of existing columns

```{r}
mutate(loans, Total_Loans = SubsidizedDL + UNSubsidizedDL)
```

## `rowwise()`

Mutate works as expected when you want to manipulate whole columns at once, but sometimes you want to do something on a row-by-row basis.

For example: this code doesn't work as you might expect

```{r}
myDF <- data.frame(x=c(1,2,3), y=c(10, 11, 12))
mutate(myDF, sum=sum(x, y))
```

## `rowwise()`

But this code computes the sum on a row-by-row basis, as you might expect

```{r}
myDF <- data.frame(x=c(1,2,3), y=c(10, 11, 12))
mutate(rowwise(myDF), sum=sum(x, y))
```


## `summarise()`

Summarizes data into a single row.  This may seem not that useful, but it will become useful when we start grouping data. 

```{r}
summarise(loans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```


## Grouping Data

These functions above get really powerful when you start grouping data based on factors in your dataset.

##`group_by()`

```{r}
groupedLoans <- group_by(loans, State)
summarise(groupedLoans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```

## Chaining operations

`dplyr` also provides a way of chaining together complicated operations with the `%>%` operator.

This prevents having to save intermediate steps, or to have a complicated series of nested functions.

## Which is easier to read?


### Option 1

```
wakeUp() %>%
getOutOfBed() %>%
eatBreafast()
leaveHouse()
```

### Option 2

```
leaveHouse(eatBreakfast(getOutOfBed(wakeUp())))
```

## Chaining operations

Note that the resulting dataframe from each step is passed as the first argument to the next function in the chain.

```{r}
myResult <- 
  group_by(loans, School_Type) %>%
    mutate(Total_Loans = SubsidizedDL + UNSubsidizedDL) %>%
    select(-State) %>%
    summarise(mean_total_loans = mean(Total_Loans, na.rm=TRUE))
myResult
```

In this example we haven't saved all the intermediate steps, so we don't have leftover dataframes floating ariound that are missing the State column. In the end, all we have is the `myResult` dataframe we saved

## Chaining works with non-`dplyr()` functions too

```{r warning=FALSE}
#chained syntax
rnorm(1000, mean=20, sd=1.4) %>% log %>% hist(main="my nice histogram")


#compare with nested function calls 

hist(log(rnorm(1000, mean=20, sd=1.4)))
```

## `do()`

do anything to grouped data

```{r}
linearModels <- loans %>% group_by(State) %>%
  do(regression=lm(UNSubsidizedDL~SubsidizedDL, data=.))
linearModels
```

## `do()`


<pre class="prettyprint lang-r">
linearModels <- loans %>% group_by(State) %>%
  do(regression=lm(UNSubsidizedDL~SubsidizedDL, data=.))
linearModels
</pre>

```{r}
linearModels %>% 
  summarize(sum=summary(regression)$r.squared)
```


## Challenge

Using the `diamonds` dataset that is built in to the `ggplot2` package:

*  calculate the mean price of diamonds for each of the different clarity ratings
*  create a new column called `volume` that is the product of x, y and z
*  plot `volume` against `carat`

## More info

A more complete introduction is available in the [`dplyr` vignette](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)

More info on `magrittr` [can be found here](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html).


## TAKE A BREAK

## Prgramming in R

R is a programming language, which means that it gives you all the tools you need to automate repetitive tasks.  There are three (or more) main ways to do this:

* `for` loops
* the `lapply()` function
* the `dplyr` package

## for loops

`for` loops will be familiar if you have ever used any other programming languages.  The basic structure looks like this:

```{r results='hide'}
vector <- 1:10
for(i in vector){
  #do something with i
}
```

## for loops

Here is a (slightly) more complicated example. 

```{r }
myVector <- 1:10
for(counter in myVector){
  result <- paste("counter ^ 2 = ", counter^2)
  print(result)
}
```


## explanation of previous loop

-  We loop over a vector `1:100`, and sequentially assign its values to a temporary variable we are calling `counter`. (Note: we can call this variable whatever we want.) 
-  Then R does what is within the curly braces `{}` for each iteration of the loop.
-  In this case, it pastes together some text with the square of the value of `counter` and prints this all to the console. 

-  <span class="mega-octicon octicon-question"></span> After running the above code, what is the value of `counter`? What is the value of `myVector`? Has this value changed?

## getting stuff out of a loop

-  Create a results vector in advance that is the same length as the vector we are looping over
-  Then save the results each time in the appropriate slot. 

```{r}
myVector <- runif(5, min = 1, max=10); myVector
results <- numeric(5)
for(each in 1:length(myVector)){
  results[each] <- paste(myVector[each], "^ 2 = ", myVector[each]^2)
}

results[3]

```

## `if` statements

-  Often during a loop, you may want to do a test and do something different based on the results of the test. 
-  Imagine a vector of germination outcomes from a seed experiment. 
-  0 indicates the seed did not germinate due to insect predatoin
-  1 indicates that it did not germinate but no insect predation occurrend
-  2 indicates that the seed germinated. 

We can use the `if()` function to evaluate the outcome and provide context specific output. 

---

```{r}
outcomes <- c(0,1,0,2,0,1,0,2,0,1,0,1,0,0)
for(trial in outcomes){
  if(trial == 2) print("Welcome to the world, plantling!")
  else print("RIP")
}
```

## Challenge

Write a `for` loop to examine the law of large numbers to illustrate how, as sample size increases, estimates of the mean of a population converge on the true value.  Do this in the following steps:

* create a numeric results vector of length 2000
* loop over each integer `i` from 1 to 2000
* at each iteration use the `rnorm()` function to simulate a sample of size `i` from a population with a mean of 100 and standard deviation of 30.
* calculate the mean of this sample, and be sure to save these results to the appropriate place in the results vector
* finally, make a plot of the results with the integers 1 to 2000 on the x axis, and the corresponding value from the results vector on the y axis

<!-- ## solution -->

<!-- ```{r} -->
<!-- results <- numeric(2000) -->
<!-- for(i in 1:2000){ -->
<!--   results[i] <- mean(rnorm(n=i, mean=100, sd=30)) -->
<!-- } -->
<!-- plot(1:2000, results, pch=16) -->
<!-- ``` -->


## `lapply()`

<div class="columns-2">

The function `lapply()` is like a `for` loop, but is optimized and explicitly functional.

`lapply()` usually takes two arguments 

-  `X` which is a list or a vector to loop over
-  `FUN` which is a function to apply to each element of `X`.  

Thus, `FUN` must be able to accept any element of `X` as an argument. 

```{r}
x <- c("dog","cat", "cucumber")
lapply(x, FUN=nchar)
```
</div>

## Writing your own functions


Functions are the best way to encapsulate code that you want to repeat again and again.  

A function accepts **arguments** and **returns** a single (and only a single) object.

Variable names defined within a function only exist within the function (not within the global environment). 

## Writing your own functions

```{r}
is.even <- function(number){
  if(number %% 2 == 0) {return("The number is even")}
  else {return("The number is not even")}
}

is.even(1233)
is.even(1234)
is.even(-1.2)
```

## Lists

The "l" in `lapply()` stands for "list", because that's what you get as a result. 

**lists can hold any type of data, not every element needs to be the same type.**

```{r}
myList <- list(firstOne=1, nextOne="too", lastOne=rnorm(10))
myList
```

## often use double brackets `[[]]` to index a list

```{r}
myList[[3]]
myList[3]
```

For five marks....what is the difference?

## `[[]]` versus `[]`


<img src='../../images/pepper.png' width=900>


## lists can (optionally) have named elements, that can be accessed using the `$` operator 

```{r}
myList$nextOne
```

Where have you seen the `$` operator before?

What does this suggest about the relationship between list and dataframes?

## Lists are useful because of their flexibility. 

We can store complex results from each iteration, and then come back to these results later. 

```{r}
# note, we must accept an argument
# even if we don't do anything with this argument.
summarizeRandom <- function(n){
  sample <- rnorm(n)
  mySummary <- summary(sample)
  return(mySummary)
}

sampleSizes <- 100:200
myResults <- lapply(sampleSizes, FUN=summarizeRandom)
myResults[1:3]
```
